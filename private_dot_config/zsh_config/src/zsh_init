#!/bin/zsh
# vim:foldmethod=marker

local SK_HEIGHT=20

# aliases {{{

alias tm="trashman"
alias l="ls -l --color=auto"
alias ls="ls --color=auto"
alias la="ls -a --color=auto"
alias grep="grep --color=auto"
alias fgrep="fgrep --color=auto"
alias egrep="egrep --color=auto"
alias diff="diff --color=auto"
alias cat="bat -pp"
alias pg="$PAGER"
alias sk="sk -p ' ' --inline-info"
alias wget="wget --hsts-file=${XDG_DATA_HOME}/wget-hsts"
alias v="$EDITOR"
alias suv="sudo $EDITOR"
alias cl="xclip -selection clipboard"
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ......="cd ../../../../.."

# }}}
# git {{{

# Load version control information
autoload -Uz vcs_info
# Format the vcs_info_msg_0_ variable
zstyle ':vcs_info:git:*' formats '(%b) '

alias ,="git"
alias ,s="git status -sb ."
alias ,status="git status"
alias ,clone="git clone"
alias ,l="git log --oneline --graph --decorate -10"
alias ,lo="git log --oneline --graph --decorate"
alias ,log="git log"
alias ,ls="git ls-files -tco"
alias ,b="git branch"
alias ,sb="git show-branch"
alias ,a="git add"
alias ,ch="git checkout"
alias ,stash="git stash"
alias ,fetch="git fetch"
alias ,pull="git pull"
alias ,push="git push"
alias ,commit="git commit"
alias ,merge="git merge"
alias ,rebase="git rebase"
alias ,apply="git apply"
alias ,d="git diff | $PAGER"
alias ,diff="git diff"
alias ,rv="git remote -v"
alias ,remote="git remote"
alias ,reset="git reset"
alias ,restore="git restore"
alias ,sm="git submodule"
alias ,rm="git rm"
alias ,mv="git mv"

# }}}
# options {{{

autoload edit-command-line
zle -N edit-command-line

# completion
fpath=($HOME/.config/zsh_config/src/completions/zsh-completions/src/ $fpath)
autoload -Uz compinit
compinit -d "$XDG_CACHE_HOME/zsh_compdump"
# zstyle ':completion:*' auto-description 'specify: %d'
# zstyle ':completion:*' completer _expand _complete _correct _approximate
# zstyle ':completion:*' format 'Completing %d'
# zstyle ':completion:*' group-name ''
# zstyle ':completion:*' menu select=2
# eval "$(dircolors -b)"
# zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
# zstyle ':completion:*' list-colors ''
# zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
# zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
# zstyle ':completion:*' menu select=long
# zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
# zstyle ':completion:*' use-compctl false
# zstyle ':completion:*' verbose true

# zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
# zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'
_comp_options+=(globdots)

# history
HISTFILE="$XDG_CACHE_HOME/zsh_history"
HISTSIZE=1000
SAVEHIST=1000
setopt hist_ignore_space
setopt hist_ignore_all_dups
setopt hist_save_no_dups
setopt inc_append_history

# type only directory name to cd
setopt auto_cd

# turn off case sensitivity
setopt no_case_glob

# expand prompt substring
setopt PROMPT_SUBST

# }}}
# functions {{{

# pick file with sk
#   if cmdline buffer is empty, open file in nvim
#   if cmdline buffer is not empty, return path of file
function __you_alone_determine_your_mark()
{
    if [ -z $BUFFER ]; then
        local file=$(fd -E .git -t f | sk --reverse --height=$SK_HEIGHT \
            --preview 'bat -ppf --line-range :500 {}')
        zle reset-prompt
        [ -z $file ] && return
        BUFFER="$EDITOR '$file'"
        zle accept-line
    else
        local file=$(fd -E .git -t f | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $file ] && return
        BUFFER+=" '$file'"
        zle end-of-line
    fi
}
zle -N __you_alone_determine_your_mark

# grip a hidden file with sk
#   if cmdline buffer is empty, open hidden file in nvim
#   if cmdline buffer is not empty, return path of hidden file
function __always_check_twice_moron()
{
    if [ -z $BUFFER ]; then
        local file=$(fd -E .git -t f -H | rg "^\." | sk --reverse --height=$SK_HEIGHT \
            --preview 'bat -ppf --line-range :500 {}')
        zle reset-prompt
        [ -z $file ] && return
        BUFFER="$EDITOR '$file'"
        zle accept-line
    else
        local file=$(fd -E .git -t f -H | rg "^\." | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $file ] && return
        BUFFER+=" '$file'"
        zle end-of-line
    fi
}
zle -N __always_check_twice_moron

# hop to a directory with sk
#   if cmdline buffer is empty, cd into directory
#   if cmdline buffer is not empty, return path of directory
function __a_fine_day_to_be_a_visitor()
{
    if [ -z $BUFFER ]; then
        local dir=$(fd -t d | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $dir ] && return
        BUFFER="cd '$dir'"
        zle accept-line
    else
        local dir=$(fd -t d | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $dir ] && return
        BUFFER+=" '$dir'"
        zle end-of-line
    fi
}
zle -N __a_fine_day_to_be_a_visitor

# hop to a hidden directory with sk
#   if cmdline buffer is empty, cd into directory
#   if cmdline buffer is not empty, return path of directory
function __you_might_be_chasing_a_ghost
{
    if [ -z $BUFFER ]; then
        local dir=$(fd -t d -H | rg "^\." | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $dir ] && return
        BUFFER="cd '$dir'"
        zle accept-line
    else
        local dir=$(fd -t d -H | rg "^\." | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $dir ] && return
        BUFFER+=" '$dir'"
        zle end-of-line
    fi
}
zle -N __you_might_be_chasing_a_ghost

# operate a file with xdg-open
function __initiative_begets_greatness()
{
    local file=$(fd -E .git -t f | sk --reverse --height=$SK_HEIGHT)
    zle reset-prompt
    [ -z $file ] && return
    xdg-open $file
}
zle -N __initiative_begets_greatness

# interrogate ps about cpu usage
function __interrogate_proc_cpu()
{
    # local proc=$(ps axuk %cpu | awk '{print $2"\t"$1"\t"$3" "$4" "$9" "$10" "$11}' |
    #     sk --reverse --no-sort --tac \
    #         --header='id      user    cpu mem start time command')
    # zle reset-prompt
    # [ -z $proc ] && return
    # echo $proc
    BUFFER=" top -o '+%CPU'"
    zle accept-line
}
zle -N __interrogate_proc_cpu

# interrogate ps about mem usage
function __interrogate_proc_mem()
{
    # local proc=$(ps axuk %mem | awk '{print $2"\t"$1"\t"$4" "$3" "$9" "$10" "$11}' |
    #     sk --reverse --no-sort --tac \
    #         --header='id      user    mem cpu start time command')
    # zle reset-prompt
    # [ -z $proc ] && return
    # echo $proc
    BUFFER=" top -o '+%MEM'"
    zle accept-line
}
zle -N __interrogate_proc_mem

function __nothing_new_under_the_sun()
{
    local env_var=$(env | sk --reverse --tac)
    zle reset-prompt
    [ -z $env_var ] && return
    if [ -z $BUFFER ]; then
        echo $env_var
    else
        BUFFER+=$env_var
        zle end-of-line
    fi
}
zle -N __nothing_new_under_the_sun

function __the_world_was_born_from_debt()
{
    local proc=$(ps axuk %cpu | awk '{print $2"\t"$1"\t"$3" "$4" "$9" "$10" "$11}' |
        sk --reverse --no-sort --tac --color=header:160 \
            --header="id      user    cpu mem start time command" | awk '{print $1}')
    zle reset-prompt
    [ -z $proc ] && return
    sudo kill $proc
}
zle -N __the_world_was_born_from_debt

function __through_the_passage_of_time()
{
    local cmd=$(bat -pp "$HISTFILE" |
        sk --reverse --tac --no-sort --height=$SK_HEIGHT)
    zle reset-prompt
    [ -z $cmd ] && return
    zle push-input
    BUFFER=$cmd
    zle end-of-line
}
zle -N __through_the_passage_of_time

export mnt="$HOME/.mnt"
function __one_departs_then_two_replace()
{
    [ ! -d $mnt ] && mkdir $mnt
    for m in $(lsblk | tail +2 | awk -F ' ' '{print $7}'); do
        if [[ $m == $mnt ]]; then
            mntdev=$(findmnt $mnt | tail -1 | cut -d' ' -f2)
            echo -n "unmount $mntdev? y/N "
            read -r -k1 yn
            zle reset-prompt
            [[ $yn == 'y' ]] && BUFFER="sudo umount '$mnt'" && zle accept-line
            return
        fi
    done
    lsblk
    local dev=$(fd . '/dev/' | sk --reverse --height=$SK_HEIGHT)
    zle reset-prompt
    [ -z $dev ] && return
    BUFFER="sudo mount '$dev' $mnt"
    zle accept-line
}
zle -N __one_departs_then_two_replace

# run updatedb before locate
function locat()
{
    sudo updatedb
    locate $1
}

# }}}
# plugins {{{

source "$ZSH_BIN/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
source "$ZSH_BIN/zsh-history-substring-search.zsh"
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND='fg=blue,bold'
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND='fg=red,bold'
eval "$(zoxide init zsh)"

# }}}
# vi mode {{{

# init vi mode
set -o vi -M viins

# new line cursor
function zle-line-init()
{
    echo -ne '\e[6 q' # beam
}
zle -N zle-line-init

# set cursor when switching keymaps
function zle-keymap-select()
{
    if [[ $KEYMAP == vicmd ]]; then
        echo -ne '\e[2 q' # block
    else
        echo -ne '\e[6 q' # beam
    fi
}
zle -N zle-keymap-select

# }}}
# key bindings {{{

bindkey '^[e' edit-command-line
bindkey -M vicmd "^H" run-help
# vi mode
bindkey 'jk' vi-cmd-mode
bindkey -M vicmd 'gh' beginning-of-line
bindkey -M vicmd 'gl' end-of-line
# emacs insert mode
bindkey -M viins "^?" backward-delete-char
bindkey -M viins "^W" backward-kill-word
bindkey -M viins "^U" backward-kill-line
bindkey -M viins '^A' beginning-of-line
bindkey -M viins '^E' end-of-line
# zsh-history-substring-search
bindkey -M viins '^P' history-substring-search-up
bindkey -M viins '^N' history-substring-search-down
bindkey -M vicmd 'k' history-substring-search-up
bindkey -M vicmd 'j' history-substring-search-down
# function key bindings
bindkey "^F"    __a_fine_day_to_be_a_visitor
bindkey "^[f"   __you_might_be_chasing_a_ghost
bindkey "^V"    __you_alone_determine_your_mark
bindkey "^[v"   __always_check_twice_moron
bindkey "^O"    __initiative_begets_greatness
bindkey "^[^E"  __nothing_new_under_the_sun
bindkey "^[^R"  __through_the_passage_of_time
bindkey "^[^K"  __the_world_was_born_from_debt
bindkey "^[^M"  __one_departs_then_two_replace
bindkey "^[^P"  __interrogate_proc_cpu
# bindkey "^[^M"  __interrogate_proc_mem
# function key bindings cmdmode
# bindkey -M vicmd "m" __a_fine_day_to_be_a_visitor
# bindkey -M vicmd "M" __you_might_be_chasing_a_ghost
# bindkey -M vicmd "v" __you_alone_determine_your_mark
# bindkey -M vicmd "V" __always_check_twice_moron
# bindkey -M vicmd "o" __initiative_begets_greatness

# }}}
