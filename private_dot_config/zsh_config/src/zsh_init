#!/bin/zsh
# vim:foldmethod=marker

KEYTIMEOUT=50
local SK_HEIGHT=20

# aliases {{{

# base
alias l="ls -l --color=auto"
alias ls="ls --color=auto"
alias la="ls -a --color=auto"
alias grep="grep --color=auto"
alias fgrep="fgrep --color=auto"
alias egrep="egrep --color=auto"
alias diff="diff --color=auto"
alias pg="$PAGER"
alias wget="wget --hsts-file=${XDG_DATA_HOME}/wget-hsts"
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ......="cd ../../../../.."
# chezmoi
alias cz="chezmoi"
# git
alias ,="git"
alias ,s="git status -sb ."
alias ,status="git status"
alias ,clone="git clone"
alias ,l="git log --oneline --graph --decorate -10"
alias ,lo="git log --oneline --graph --decorate"
alias ,log="git log"
alias ,ls="git ls-files -tco"
alias ,b="git branch"
alias ,sb="git show-branch"
alias ,a="git add"
alias ,ch="git checkout"
alias ,stash="git stash"
alias ,fetch="git fetch"
alias ,pull="git pull"
alias ,push="git push"
alias ,commit="git commit"
alias ,merge="git merge"
alias ,rebase="git rebase"
alias ,apply="git apply"
alias ,d="git diff | $PAGER"
alias ,diff="git diff"
alias ,rv="git remote -v"
alias ,remote="git remote"
alias ,reset="git reset"
alias ,restore="git restore"
alias ,mod="git submodule"
alias ,rm="git rm"
alias ,mv="git mv"
# bat
alias cat="bat -pp"
# skim
alias sk="sk -p ' ' --inline-info"
# xclip
alias cl="xclip -selection clipboard"
# neovim
alias v="$EDITOR"
alias suv="sudo $EDITOR"
# trashman
alias tm="trashman"

# }}}
# options {{{

# Load git version control information
autoload -Uz vcs_info

# Format the vcs_info_msg_0_ variable
zstyle ':vcs_info:git:*' formats '(%b) '

# edit line in $EDITOR
autoload edit-command-line
zle -N edit-command-line

# completion
fpath=($HOME/.config/zsh_config/src/completions/zsh-completions/src/ $fpath)
autoload -Uz compinit
compinit -d "$XDG_CACHE_HOME/zsh_compdump"
# zstyle ':completion:*' auto-description 'specify: %d'
# zstyle ':completion:*' completer _expand _complete _correct _approximate
# zstyle ':completion:*' format 'Completing %d'
# zstyle ':completion:*' group-name ''
# zstyle ':completion:*' menu select=2
# eval "$(dircolors -b)"
# zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
# zstyle ':completion:*' list-colors ''
# zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
# zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
# zstyle ':completion:*' menu select=long
# zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
# zstyle ':completion:*' use-compctl false
# zstyle ':completion:*' verbose true

# zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
# zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'
_comp_options+=(globdots)

# history
HISTFILE="$XDG_CACHE_HOME/zsh_history"
HISTSIZE=1000
SAVEHIST=1000
setopt hist_ignore_space
setopt hist_ignore_all_dups
setopt hist_save_no_dups
setopt inc_append_history

# type only directory name to cd
setopt auto_cd

# turn off case sensitivity
setopt no_case_glob

# expand prompt substring
setopt PROMPT_SUBST

# # wildcard fix maybe??
# setopt extended_glob

# }}}
# functions {{{

# pick file with sk
#   if cmdline buffer is empty, open file in nvim
#   if cmdline buffer is not empty, return path of file
function __find_file()
{
    if [ -z $BUFFER ]; then
        local file=$(fd -E .git -t f | sk --reverse --height=$SK_HEIGHT \
            --preview 'bat -ppf --line-range :500 {}')
        zle reset-prompt
        [ -z $file ] && return
        BUFFER="$EDITOR '$file'"
        zle accept-line
    else
        local file=$(fd -E .git -t f | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $file ] && return
        BUFFER+=" '$file'"
        zle end-of-line
    fi
}
zle -N __find_file

# grip a hidden file with sk
#   if cmdline buffer is empty, open hidden file in nvim
#   if cmdline buffer is not empty, return path of hidden file
function __find_hidden_file()
{
    if [ -z $BUFFER ]; then
        local file=$(fd -E .git -t f -H | rg "^\." | sk --reverse --height=$SK_HEIGHT \
            --preview 'bat -ppf --line-range :500 {}')
        zle reset-prompt
        [ -z $file ] && return
        BUFFER="$EDITOR '$file'"
        zle accept-line
    else
        local file=$(fd -E .git -t f -H | rg "^\." | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $file ] && return
        BUFFER+=" '$file'"
        zle end-of-line
    fi
}
zle -N __find_hidden_file

# hop to a directory with sk
#   if cmdline buffer is empty, cd into directory
#   if cmdline buffer is not empty, return path of directory
function __find_directory()
{
    if [ -z $BUFFER ]; then
        local dir=$(fd -t d | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $dir ] && return
        BUFFER="cd '$dir'"
        zle accept-line
    else
        local dir=$(fd -t d | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $dir ] && return
        BUFFER+=" '$dir'"
        zle end-of-line
    fi
}
zle -N __find_directory

# hop to a hidden directory with sk
#   if cmdline buffer is empty, cd into directory
#   if cmdline buffer is not empty, return path of directory
function __find_hidden_directory
{
    if [ -z $BUFFER ]; then
        local dir=$(fd -t d -H | rg "^\." | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $dir ] && return
        BUFFER="cd '$dir'"
        zle accept-line
    else
        local dir=$(fd -t d -H | rg "^\." | sk --reverse --height=$SK_HEIGHT)
        zle reset-prompt
        [ -z $dir ] && return
        BUFFER+=" '$dir'"
        zle end-of-line
    fi
}
zle -N __find_hidden_directory

# operate a file with xdg-open
function __open_file()
{
    local file=$(fd -E .git -t f | sk --reverse --height=$SK_HEIGHT)
    zle reset-prompt
    [ -z $file ] && return
    xdg-open $file
}
zle -N __open_file

# interrogate ps about cpu usage
function __list_pid()
{
    # local proc=$(ps axuk %cpu | awk '{print $2"\t"$1"\t"$3" "$4" "$9" "$10" "$11}' |
    #     sk --reverse --no-sort --tac \
    #         --header='id      user    cpu mem start time command')
    # zle reset-prompt
    # [ -z $proc ] && return
    # echo $proc
    # BUFFER=" top -o '+%CPU'"
    BUFFER=" htop --sort-key=PERCENT_CPU"
    zle accept-line
}
zle -N __list_pid

# interrogate ps about mem usage
function __interrogate_proc_mem()
{
    # local proc=$(ps axuk %mem | awk '{print $2"\t"$1"\t"$4" "$3" "$9" "$10" "$11}' |
    #     sk --reverse --no-sort --tac \
    #         --header='id      user    mem cpu start time command')
    # zle reset-prompt
    # [ -z $proc ] && return
    # echo $proc
    BUFFER=" top -o '+%MEM'"
    zle accept-line
}
zle -N __interrogate_proc_mem

function __find_env()
{
    local env_var=$(env | sk --reverse --tac)
    zle reset-prompt
    [ -z $env_var ] && return
    if [ -z $BUFFER ]; then
        echo $env_var
    else
        BUFFER+=$env_var
        zle end-of-line
    fi
}
zle -N __find_env

function __kill_pid()
{
    local proc=$(ps axuk %cpu | awk '{print $2"\t"$1"\t"$3" "$4" "$9" "$10" "$11}' |
        sk --reverse --no-sort --tac --color=header:160 \
            --header="id      user    cpu mem start time command" | awk '{print $1}')
    zle reset-prompt
    [ -z $proc ] && return
    sudo kill $proc
}
zle -N __kill_pid

function __find_hist()
{
    local cmd=$(bat -pp "$HISTFILE" |
        sk --reverse --tac --no-sort --height=$SK_HEIGHT)
    zle reset-prompt
    [ -z $cmd ] && return
    zle push-input
    BUFFER=$cmd
    zle end-of-line
}
zle -N __find_hist

export mnt="$HOME/.mnt"
function __mount_drive()
{
    [ ! -d $mnt ] && mkdir $mnt
    for m in $(lsblk | tail +2 | awk -F ' ' '{print $7}'); do
        if [[ $m == $mnt ]]; then
            mntdev=$(findmnt $mnt | tail -1 | cut -d' ' -f2)
            echo -n "unmount $mntdev? y/N "
            read -r -k1 yn
            zle reset-prompt
            [[ $yn == 'y' ]] && BUFFER="sudo umount '$mnt'" && zle accept-line
            return
        fi
    done
    lsblk
    local dev=$(fd . '/dev/' | sk --reverse --height=$SK_HEIGHT)
    zle reset-prompt
    [ -z $dev ] && return
    BUFFER="sudo mount '$dev' $mnt"
    zle accept-line
}
zle -N __mount_drive

# run updatedb before locate
function locat()
{
    sudo updatedb
    locate $1
}

# }}}
# plugins {{{

# zoxide
eval "$(zoxide init zsh)"

# syntax highlighting
source "$ZSH_BIN/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"

# history substring
source "$ZSH_BIN/zsh-history-substring-search.zsh"
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND='fg=blue,bold'
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND='fg=red,bold'

# }}}
# emacs mode {{{

set -o emacs

# nav
bindkey -M emacs "^[h" __find_file
bindkey -M emacs "^[g" __find_directory
bindkey -M emacs "^[vh" __find_hidden_file
bindkey -M emacs "^[mh" __find_hidden_file
bindkey -M emacs "^[vg" __find_hidden_directory
bindkey -M emacs "^[mg" __find_hidden_directory
# xdg-open
bindkey -M emacs "^[vo" __open_file
bindkey -M emacs "^[mo" __open_file
# env
bindkey -M emacs "^[ve" __find_env
bindkey -M emacs "^[me" __find_env
# hist
bindkey -M emacs "^[vr" __find_hist
bindkey -M emacs "^[mr" __find_hist
# mount
bindkey -M emacs "^[vd" __mount_drive
bindkey -M emacs "^[md" __mount_drive
# pid
bindkey -M emacs "^[vk" __kill_pid
bindkey -M emacs "^[mk" __kill_pid
bindkey -M emacs "^[vp" __list_pid
bindkey -M emacs "^[mp" __list_pid
# zsh-history-substring-search
bindkey -M emacs '^P' history-substring-search-up
bindkey -M emacs '^N' history-substring-search-down
bindkey -M emacs '^[p' history-substring-search-up
bindkey -M emacs '^[n' history-substring-search-down
bindkey -M emacs '<Up>' history-substring-search-up
bindkey -M emacs '<Down>' history-substring-search-down

# }}}
# vi mode {{{
#
# # init vi mode
# set -o vi -M viins
#
# # new line cursor
# function zle-line-init()
# {
#     echo -ne '\e[6 q' # beam
# }
# zle -N zle-line-init
#
# # set cursor when switching keymaps
# function zle-keymap-select()
# {
#     if [[ $KEYMAP == vicmd ]]; then
#         echo -ne '\e[2 q' # block
#     else
#         echo -ne '\e[6 q' # beam
#     fi
# }
# zle -N zle-keymap-select
#
# bindkey '^[e' edit-command-line
# bindkey -M vicmd "^H" run-help
# # vi mode
# bindkey 'jk' vi-cmd-mode
# bindkey -M vicmd 'gh' beginning-of-line
# bindkey -M vicmd 'gl' end-of-line
# # emacs insert mode
# bindkey -M viins "^?" backward-delete-char
# bindkey -M viins "^W" backward-kill-word
# bindkey -M viins "^U" backward-kill-line
# bindkey -M viins '^A' beginning-of-line
# bindkey -M viins '^E' end-of-line
# # zsh-history-substring-search
# bindkey -M viins '^P' history-substring-search-up
# bindkey -M viins '^N' history-substring-search-down
# bindkey -M vicmd 'k' history-substring-search-up
# bindkey -M vicmd 'j' history-substring-search-down
# # function key bindings
# bindkey "^F"    __find_directory
# bindkey "^[f"   __find_hidden_directory
# bindkey "^V"    __find_file
# bindkey "^[v"   __find_hidden_file
# bindkey "^O"    __open_file
# bindkey "^[^E"  __find_env
# bindkey "^[^R"  __find_hist
# bindkey "^[^K"  __kill_pid
# bindkey "^[^M"  __mount_drive
# bindkey "^[^P"  __list_pid
# # bindkey "^[^M"  __interrogate_proc_mem
#
# # }}}
